#!/usr/bin/env bash
# direnv configuration for webapp-team-app
# Provides convenient aliases for Docker-based development

# Default docker-compose service names
export DX_SERVICE=app
export DX_DB_SERVICE=postgres

# Set default environment for local development
export BUILD_TARGET=development
export NODE_ENV=development

# General-purpose helper to run commands in the app container
dx() {
  local CONTAINER
  CONTAINER=$(docker compose ps -q "$DX_SERVICE" 2>/dev/null || true)

  if [ -n "$CONTAINER" ] && [ "$(docker inspect -f '{{.State.Running}}' "$CONTAINER" 2>/dev/null || echo false)" = "true" ]; then
    docker exec -it "$CONTAINER" "$@"
  else
    docker compose --profile test run --rm "$DX_SERVICE" "$@"
  fi
}

# Database helper
dx_db() {
  local CONTAINER
  CONTAINER=$(docker compose ps -q "$DX_DB_SERVICE" 2>/dev/null || true)

  if [ -n "$CONTAINER" ] && [ "$(docker inspect -f '{{.State.Running}}' "$CONTAINER" 2>/dev/null || echo false)" = "true" ]; then
    docker exec -it "$CONTAINER" "$@"
  else
    docker compose --profile test run --rm "$DX_DB_SERVICE" "$@"
  fi
}

# Start services if not running
dx_start() {
  if [ -z "$(docker compose ps -q 2>/dev/null)" ]; then
    echo "üöÄ Starting development environment..."
    docker compose --profile test up -d
    sleep 3
    echo "‚úÖ Development environment ready!"
  fi
}

# Node/npm aliases
alias npm='dx npm'
alias npx='dx npx'
alias node='dx node'
alias jest='dx npx jest'

# Database aliases
alias psql='dx_db psql -U postgres -d webapp_test'
alias pg_dump='dx_db pg_dump -U postgres webapp_test'
alias migrate='dx npm run migrate'
alias migrate:test='dx npm run migrate:test'

# Testing aliases
alias test='dx npm test'
alias test:unit='dx npm run test:unit'
alias test:integration='dx npm run test:integration'
alias test:all='dx npm run test:all'
alias test:watch='dx npx jest --watch'

# Test shortcuts (Rails/Phoenix style)
# Run specific test file: t path/to/test.js
# Run specific test by line: t path/to/test.js:42
# Run tests matching pattern: t -t "should create user"
t() {
  local file=""
  local line=""
  local extra_args=""
  
  # Parse arguments
  for arg in "$@"; do
    if [[ $arg == *":"* ]]; then
      # Handle file:line format
      file="${arg%:*}"
      line="${arg#*:}"
    elif [[ -f $arg ]] || [[ $arg == *.js ]]; then
      # It's a file
      file="$arg"
    else
      # Collect other arguments
      extra_args="$extra_args $arg"
    fi
  done
  
  # Build jest command
  local cmd="npx jest"
  
  # Add file if specified
  if [ -n "$file" ]; then
    cmd="$cmd $file"
  fi
  
  # Add line number as test name pattern if specified
  # Note: Jest doesn't support line numbers directly, but we can try to match test names
  if [ -n "$line" ]; then
    echo "‚ö†Ô∏è  Note: Jest doesn't support line numbers directly. Running all tests in file."
    echo "    Use 't -t \"test name\"' to run specific tests."
  fi
  
  # Add any extra arguments
  if [ -n "$extra_args" ]; then
    cmd="$cmd $extra_args"
  fi
  
  # Ensure environment is running
  dx_start
  
  # Run the test
  echo "üß™ Running: $cmd"
  dx $cmd
}

# Shortcuts for common test patterns
alias t:app='t app.test.js'
alias t:db='t db.test.js'
alias t:int='t test/integration/'
alias t:unit='t --testPathIgnorePatterns=/test/integration/'

# Run test with coverage
tc() {
  dx_start
  dx npx jest --coverage "$@"
}

# Run test in watch mode
tw() {
  dx_start
  dx npx jest --watch "$@"
}

# Run only tests matching a pattern
tt() {
  if [ -z "$1" ]; then
    echo "Usage: tt \"pattern\""
    echo "Example: tt \"should create user\""
    return 1
  fi
  dx_start
  dx npx jest -t "$@"
}

# Run failed tests from last run
alias t:failed='dx npx jest --onlyFailures'

# Development shortcuts
alias dev='dx npm run dev'
alias start='dx npm start'
alias lint='dx npm run lint'
alias format='dx npm run format'
alias shell='dx sh'
alias bash='dx bash'

# Docker compose shortcuts
alias dc='docker compose'
alias dcup='docker compose --profile test up -d'
alias dcdown='docker compose --profile test down'
alias dclogs='docker compose logs -f'
alias dcps='docker compose ps'
alias dcrestart='docker compose --profile test restart'
alias dcrebuild='docker compose --profile test up -d --build'

# Helpful functions
run_tests() {
  echo "üß™ Running tests..."
  dx_start
  dx npm run migrate:test
  dx npm run test:integration
  dx npx jest app.test.js --coverage=false
}

clean_env() {
  echo "üßπ Cleaning up Docker environment..."
  docker compose --profile test down -v
  echo "‚úÖ Environment cleaned!"
}

db_console() {
  echo "üóÑÔ∏è Connecting to database..."
  dx_db psql -U postgres -d webapp_test
}

# Show available commands when entering directory
echo "üöÄ webapp-team-app development environment loaded!"
echo ""
echo "Test shortcuts:"
echo "  t <file>           - Run specific test file"
echo "  t <file>:42        - Run test at line 42 (shows all tests in file)"
echo "  tt \"pattern\"       - Run tests matching pattern"
echo "  tw [file]          - Run tests in watch mode"
echo "  tc [file]          - Run tests with coverage"
echo "  t:app              - Run app.test.js"
echo "  t:db               - Run db.test.js"
echo "  t:int              - Run integration tests"
echo "  t:unit             - Run unit tests only"
echo "  t:failed           - Re-run failed tests"
echo ""
echo "Other commands:"
echo "  npm, npx, node     - Node.js commands"
echo "  migrate            - Run migrations"
echo "  psql               - Database console"
echo "  shell              - Container shell"
echo "  dcup/dcdown        - Start/stop Docker"
echo "  clean_env()        - Clean everything"
echo ""
echo "Examples:"
echo "  t app.test.js"
echo "  tt \"should return healthy status\""
echo "  tw test/integration/"
echo ""
echo "All commands run inside Docker automatically!"